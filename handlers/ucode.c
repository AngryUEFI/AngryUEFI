#include "ucode.h"

#include <Base.h>
#include <Library/BaseLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/PrintLib.h>
#include <Protocol/SimpleTextOut.h>
#include <Uefi.h>
#include <Library/MemoryAllocationLib.h>

#include "Protocol.h"
#include "AngryUEFI.h"
#include "stubs.h"
#include "data/ucode-original-0x17-0x71.h"
#include "data/ucode-original-0x19-0x21.h"
#include "data/ucode-template-0x00870F10.h"
#include "data/ucode-template-0x00A20F12.h"
#include "data/ucode-template-0x00A60F12.h"
#include "handlers/ucode_execute.h"
#include "system/fault_handling.h"

#define ORIGINAL_UCODE ucode_cpu00870F10_template
#define ORIGINAL_UCODE_LEN ucode_cpu00870F10_template_len

UcodeContainer ucodes[UCODE_SLOTS] = {0};
MachineCodeContainer machine_codes[MACHINE_CODE_SLOTS] = {0};

UINT8* original_ucode = NULL;

EFI_STATUS handle_send_ucode(UINT8* payload, UINTN payload_length, ConnectionContext* ctx) {
    PrintDebug(L"Handling SENDUCODE message.\n");
    if (payload_length < 8) {
        FormatPrintDebug(L"SENDUCODE is too short, need at least 8 Bytes, got %u.\n", payload_length);
        send_status(0x1, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    UINT32 target_slot = ((UINT32*)payload)[0];
    UINT32 ucode_size = ((UINT32*)payload)[1];

    if (target_slot > UCODE_SLOTS - 1) {
        FormatPrintDebug(L"Invalid target slot, got %u, max %u.\n", target_slot, UCODE_SLOTS - 1);
        send_status(0x2, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    if (ucodes[target_slot].ucode == NULL) {
        ucodes[target_slot].ucode = AllocateZeroPool(UCODE_SIZE);
        if (ucodes[target_slot].ucode == NULL) {
            FormatPrintDebug(L"Unable to allocate memory for ucode.\n");
            send_status(0x3, FormatBuffer, ctx);
            return EFI_INVALID_PARAMETER;
        }
    }
    ucodes[target_slot].length = ucode_size;
    CopyMem(ucodes[target_slot].ucode, payload + 8, ucode_size);
    
    send_status(0x0, NULL, ctx);

    return EFI_SUCCESS;
}

void flip_bit(UINT8* ucode, UINT64 ucode_length, UINT32 position) {
    if (position / 8 >= ucode_length)
        return;
    ucode[position / 8] ^= 1 << (position % 8);
}

EFI_STATUS handle_flip_bits(UINT8* payload, UINTN payload_length, ConnectionContext* ctx) {
    PrintDebug(L"Handling FLIPBITS message.\n");
    if (payload_length < 8) {
        FormatPrint(L"FLIPBITS is too short, need at least 8 Bytes, got %u.\n", payload_length);
        send_status(0x1, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    UINT32 target_slot = ((UINT32*)payload)[0];
    UINT32 num_flips = ((UINT32*)payload)[1];

    if (target_slot > UCODE_SLOTS - 1) {
        FormatPrint(L"Invalid target slot, got %u, max %u.\n", target_slot, UCODE_SLOTS - 1);
        send_status(0x2, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }
    if (ucodes[target_slot].ucode == NULL) {
        FormatPrint(L"Slot %u is empty\n", target_slot);
        send_status(0x3, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }
    
    if (target_slot != 1) {
        if (ucodes[1].ucode == NULL) {
            ucodes[1].ucode = AllocateZeroPool(UCODE_SIZE);
            ucodes[1].length = ORIGINAL_UCODE_LEN;
        }
        CopyMem(ucodes[1].ucode, ucodes[target_slot].ucode, ucodes[target_slot].length);
        ucodes[1].length = ucodes[target_slot].length;
    }

    UINT32* flips = ((UINT32*)payload) + 2;
    for (UINTN i = 0; i < num_flips; i++) {
        flip_bit(ucodes[1].ucode, ucodes[target_slot].length, flips[i]);
    }
    
    send_status(0x0, NULL, ctx);

    return EFI_SUCCESS;
}

EFI_STATUS handle_apply_ucode(UINT8* payload, UINTN payload_length, ConnectionContext* ctx) {
    PrintDebug(L"Handling MSG_APPLYUCODE message.\n");
    if (payload_length < 8) {
        FormatPrint(L"MSG_APPLYUCODE is too short, need at least 8 Bytes, got %u.\n", payload_length);
        send_status(0x1, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    UINT32 target_slot = ((UINT32*)payload)[0];
    UINT32 options = ((UINT32*)payload)[1];
    if (ucodes[target_slot].ucode == NULL || ucodes[target_slot].length == 0) {
        FormatPrint(L"Target slot %u is empty.\n", target_slot);
        send_status(0x2, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    UINT8* ucode = ucodes[target_slot].ucode;
    UINT64 ucode_len = ucodes[target_slot].length;
    UINT64 ret = 0ull;
    UINT64 intterrupt_value = 0ull;
    // generated by iterating the entire ucode
    // this should fill the cache with this update
    // the value is passed to the apply ucode functions
    // so the compiler can not optimze them out
    UINT64 dummy = 0xdeadbeefdeadc0deull;
    for (UINT64 i = 0; i < ucode_len; i += 8) {
        for (UINT64 j = 0; j < 8; j++) {
            UINT8 b = ucode[i + j];
            dummy ^= ((UINT64)b) << j;
        }
    }
    intterrupt_value = dummy;
    if ((options & 0x01) == 0x01) {
        PrintDebug(L"Restoring after ucode.\n");
        ret = apply_ucode_restore(ucode, &intterrupt_value);
    } else {
        PrintDebug(L"NOT Restoring after ucode.\n");
        ret = apply_ucode_simple(ucode, &intterrupt_value);
    }

    UINT64* payload_u64 = (UINT64*)payload_buffer;
    payload_u64[0] = ret;
    payload_u64[1] = intterrupt_value;
    const UINTN response_size = 16;

    EFI_STATUS Status = construct_message(response_buffer, sizeof(response_buffer), MSG_UCODERESPONSE, payload_buffer, response_size, TRUE);
    if (EFI_ERROR(Status)) {
        FormatPrint(L"Unable to construct message: %r.\n", Status);
        return Status;
    }

    Status = send_message(response_buffer, response_size + HEADER_SIZE, ctx);
    if (EFI_ERROR(Status)) {
        FormatPrint(L"Unable to send message: %r.\n", Status);
        return Status;
    }

    return EFI_SUCCESS;
}

SMP_SAFE static void read_msr(CoreContext*, void* arg) {
    UINT32* buf_u32 = (UINT32*)arg;
    UINT32 target_msr = buf_u32[0];
    UINT64 ret = read_msr_stub(target_msr);
    buf_u32[0] = ret & 0xFFFFFFFF;
    buf_u32[1] = ret >> 32;
}

static EFI_STATUS send_msr_response(UINT32 values[2], ConnectionContext* ctx) {
    FormatPrintDebug(L"EAX: 0x%08X, EDX: 0x%08X.\n", values[0], values[1]); 

    const UINTN payload_size = 2 * sizeof(UINT32);
    EFI_STATUS Status = construct_message(response_buffer, sizeof(response_buffer), MSG_MSRRESPONSE, (UINT8*)values, payload_size, TRUE);
    if (EFI_ERROR(Status)) {
        FormatPrint(L"Unable to construct message: %r.\n", Status);
        return Status;
    }

    Status = send_message(response_buffer, payload_size + HEADER_SIZE, ctx);
    if (EFI_ERROR(Status)) {
        FormatPrint(L"Unable to send message: %r.\n", Status);
        return Status;
    }

    return EFI_SUCCESS;
}

EFI_STATUS handle_read_msr(UINT8* payload, UINTN payload_length, ConnectionContext* ctx) {
    PrintDebug(L"Handling MSG_READMSR message.\n");
    if (payload_length < 4) {
        FormatPrint(L"MSG_READMSR is too short, need at least 4 Bytes, got %u.\n", payload_length);
        send_status(0x1, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    UINT32 buf_u32[2] = {0};
    UINT32 target_msr = *(UINT32*)payload;
    buf_u32[0] = target_msr;

    read_msr(NULL, buf_u32);

    return send_msr_response(buf_u32, ctx);
}

EFI_STATUS handle_read_msr_on_core(UINT8* payload, UINTN payload_length, ConnectionContext* ctx) {
    EFI_STATUS status = EFI_SUCCESS;
    PrintDebug(L"Handling MSG_READMSRONCORE message.\n");
    if (payload_length < 12) {
        FormatPrint(L"MSG_READMSRONCORE is too short, need at least 12 Bytes, got %u.\n", payload_length);
        send_status(0x1, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    UINT32 target_msr = *(UINT32*)payload;
    UINT64 core_id = *(UINT64*)(payload + 4);

    if (core_id == 0) {
        return handle_read_msr(payload, payload_length, ctx);
    }

    UINT32 buf_u32[2] = {0};
    buf_u32[0] = target_msr;

    status = acquire_core_lock_for_job(core_id, ctx);
    if (status != EFI_SUCCESS) {
        return status;
    }
    CoreContext* context = &core_contexts[core_id];

    clear_core_functions(context);
    context->core_functions[0].func = read_msr;
    context->core_functions[0].arg = buf_u32;
    context->job_queued = 1;

    // execution starts
    unlock_context(context);
    if (wait_on_ap_exec(context, 100)) {
        FormatPrint(L"Core %u was ready, but did not respond to read msr in 100ms, likely stuck?\n", core_id);
        send_status(0x2, FormatBuffer, ctx);
        return EFI_TIMEOUT;
    }

    return send_msr_response(buf_u32, ctx);
}

UINT64* get_idt_address() {
    UINT8* idt_structure = read_idt_position();
    UINT8* idt_addr = (idt_structure+2);
    return (UINT64*)idt_addr;
}

static void InstallCustomGpfHandler() {
    // Get the pointer to the IDT descriptor and its backing store.
    UINT8 *IdtInfo = read_idt_position();
    if (IdtInfo == NULL) {
        // Handle error as needed.
        return;
    }

    // Cast the returned pointer to an IDT_DESCRIPTOR.
    IDT_DESCRIPTOR *IdtDesc = (IDT_DESCRIPTOR*) IdtInfo;
    // Calculate the number of entries in the IDT.
    UINTN IdtEntryCount = (IdtDesc->Limit + 1) / sizeof(IDT_ENTRY);

    // For demonstration, print out the current IDT base (if you have a print function)
    FormatPrint(L"Original IDT base = 0x%lx, limit = 0x%x\n", IdtDesc->Base, IdtDesc->Limit);

    // Get a pointer to the array of IDT entries.
    IDT_ENTRY *IdtEntries = (IDT_ENTRY*)(UINTN)IdtDesc->Base;

    // Select the vector for the General Protection Fault (typically vector 13).
    UINTN Vector = 13;
    if (Vector >= IdtEntryCount) {
        // Out of range, handle error.
        return;
    }

    // Set up the new entry to point to your custom handler.
    UINT64 HandlerAddr = (UINT64) gpf_handler;
    IdtEntries[Vector].OffsetLow      = (UINT16)(HandlerAddr & 0xFFFF);
    IdtEntries[Vector].SegmentSelector  = CODE_SEGMENT;
    IdtEntries[Vector].Ist              = 0;            // Use default stack.
    IdtEntries[Vector].Attributes       = 0x8E;         // Present, DPL=0, 64-bit interrupt gate.
    IdtEntries[Vector].OffsetMid        = (UINT16)((HandlerAddr >> 16) & 0xFFFF);
    IdtEntries[Vector].OffsetHigh       = (UINT32)((HandlerAddr >> 32) & 0xFFFFFFFF);
    IdtEntries[Vector].Reserved         = 0;

    // Finally, write back the updated IDT.
    write_idt_position();
}

void log_panic() {
    Print(L"Hello from gpf!\n");
}

// we alloc space for the update and copy it there even though the
// original ucode would suffice
// this allows slot 0 to be used like any other slot
// this is important to replace the known good update if needed
static void ensure_ucode_slot_0() {
    if (ucodes[0].ucode == NULL) {
        ucodes[0].ucode = AllocateZeroPool(UCODE_SIZE);
        CopyMem(ucodes[0].ucode, ORIGINAL_UCODE, ORIGINAL_UCODE_LEN);
        ucodes[0].length = ORIGINAL_UCODE_LEN;

        original_ucode = ucodes[0].ucode;
    }
}

void init_ucode() {
    ensure_ucode_slot_0();
    InstallCustomGpfHandler();
    init_ucode_execute();
}
