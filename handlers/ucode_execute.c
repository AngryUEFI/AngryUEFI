#include "ucode_execute.h"

#include <Base.h>
#include <Library/BaseLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/PrintLib.h>
#include <Protocol/SimpleTextOut.h>
#include <Uefi.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/UefiBootServicesTableLib.h>

#include "Protocol.h"
#include "AngryUEFI.h"
#include "stubs.h"
#include "smp.h"
#include "ucode.h"
#include "cores.h"

static EFI_STATUS check_job_parameters(JobParameters* job_parameters, ConnectionContext* ctx) {
    if (job_parameters->ucode_slot >= UCODE_SLOTS) {
        FormatPrint(L"Target ucode slot %u is unsupported, only have %u slots.\n", job_parameters->ucode_slot, UCODE_SLOTS);
        send_status(0x101, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    if (job_parameters->machine_code_slot >= MACHINE_CODE_SLOTS) {
        FormatPrint(L"Target machine code slot %u is unsupported, only have %u slots.\n", job_parameters->machine_code_slot, MACHINE_CODE_SLOTS);
        send_status(0x102, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    if (ucodes[job_parameters->ucode_slot].ucode == NULL || ucodes[job_parameters->ucode_slot].length == 0) {
        FormatPrint(L"Target ucode slot %u is empty.\n", job_parameters->ucode_slot);
        send_status(0x103, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    if (machine_codes[job_parameters->machine_code_slot].machine_code == NULL || machine_codes[job_parameters->machine_code_slot].length == 0) {
        FormatPrint(L"Target machine code slot %u is empty.\n", job_parameters->machine_code_slot);
        send_status(0x104, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    return EFI_SUCCESS;
}

static void job_parameters_from_payload(JobParameters* job_parameters, UINT8* payload) {
    UINT32* payload_u32 = (UINT32*)payload;

    UINT32 target_ucode_slot = payload_u32[0];
    UINT32 target_machine_code_slot = payload_u32[1];
    UINT32 target_core_id = payload_u32[2];
    UINT32 timeout = payload_u32[3];
    UINT32 options = payload_u32[4];

    job_parameters->core_id = target_core_id;
    job_parameters->machine_code_slot = target_machine_code_slot;
    job_parameters->ucode_slot = target_ucode_slot;
    job_parameters->timeout = timeout;
    job_parameters->options = options;
}

static SMP_SAFE void prepare_ucode_update(CoreContext* context, void*) {
    // generated by iterating the entire ucode
    // this should fill the cache on this core with this update
    // the value is put into the scratch space
    // so the compiler can not optimze it out
    UINT64 dummy = 0xdeadbeefdeadc0deull;
    for (UINT64 i = 0; i < context->current_microcode_len; i += 8) {
        for (UINT64 j = 0; j < 8; j++) {
            UINT8 b = ((UINT8*)context->current_microcode_slot_address)[i + j];
            dummy ^= ((UINT64)b) << j;
        }
    }

    *(UINT64*)context->scratch_space = dummy;
}

static void write_job_infos(JobParameters* job_parameters, CoreContext* context) {
    ZeroMem(context->result_buffer, context->result_buffer_len);
    context->current_machine_code_slot_address = machine_codes[job_parameters->machine_code_slot].machine_code;
    context->current_microcode_slot_address = ucodes[job_parameters->ucode_slot].ucode;
    context->ret_gpf_value = 0;
    context->ret_rdtsc_value = 0;
    context->current_microcode_len = ucodes[job_parameters->ucode_slot].length;
    clear_core_functions(context);

    // fill core cache with ucode
    context->core_functions[0].func = prepare_ucode_update;

    if ((job_parameters->options & 0x01) == 0x01) {
        context->core_functions[1].func = apply_ucode_execute_machine_code_restore;
    } else {
        context->core_functions[1].func = apply_ucode_execute_machine_code_simple;
    }
}

static EFI_STATUS send_result_message(CoreContext* context, UINT64 flags, BOOLEAN is_last_message, ConnectionContext* ctx) {
    UINT64* payload_u64 = (UINT64*)payload_buffer;
    payload_u64[0] = context->ret_rdtsc_value;
    payload_u64[1] = context->ret_gpf_value;
    payload_u64[2] = flags;
    payload_u64[3] = context->result_buffer_len;
    const UINTN fixed_payload_len = 4 * sizeof(UINT64);
    CopyMem(payload_buffer + fixed_payload_len, context->result_buffer, context->result_buffer_len);
    const UINTN response_size = fixed_payload_len + context->result_buffer_len;

    EFI_STATUS status = construct_message(response_buffer, sizeof(response_buffer), MSG_UCODEEXECUTETESTRESPONSE, payload_buffer, response_size, is_last_message);
    if (EFI_ERROR(status)) {
        FormatPrint(L"Unable to construct message: %r.\n", status);
        return status;
    }

    status = send_message(response_buffer, response_size + HEADER_SIZE, ctx);
    if (EFI_ERROR(status)) {
        FormatPrint(L"Unable to send message: %r.\n", status);
        return status;
    }

    return EFI_SUCCESS;
}

EFI_STATUS handle_apply_ucode_execute_test(UINT8* payload, UINTN payload_length, ConnectionContext* ctx) {
    PrintDebug(L"Handling MSG_APPLYUCODEEXCUTETEST message.\n");
    EFI_STATUS status = EFI_SUCCESS;
    if (payload_length < 20) {
        FormatPrint(L"MSG_APPLYUCODEEXCUTETEST is too short, need at least 20 Bytes, got %u.\n", payload_length);
        send_status(0x1, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    // used to pass job information between functions easier
    JobParameters job_parameters_v = {0};
    JobParameters* job_parameters = &job_parameters_v;
   
    job_parameters_from_payload(job_parameters, payload);

    status = check_job_parameters(job_parameters, ctx);
    if (status != EFI_SUCCESS) {
        return status;
    }

    // try to get a lock on target core's context
    // if this fails the core is still busy or hung
    // or we are in a weird state and should not use the core anyway
    status = acquire_core_lock_for_job(job_parameters->core_id, ctx);
    if (status != EFI_SUCCESS) {
        return status;
    }

    // core is locked by us, write the job infos
    CoreContext* context = &core_contexts[job_parameters->core_id];
    write_job_infos(job_parameters, context);

    context->job_queued = 1;

    UINT64 flags = 0ull;
    if (job_parameters->core_id == 0) {
        // synchronous execution on boot core
        // context is still locked here
        context->ready = 0;
        context->job_queued = 0;

        call_core_functions(context);

        context->ready = 1;

        // core 0 is done with synchronous execution
        unlock_context(context);
    } else {
        // an AP will now grab the job
        unlock_context(context);

        // wait for requested timeout
        // or until job completes
        // timeout == 0 means wait forever (not recommended)
        UINT64 timeout = job_parameters->timeout;
        BOOLEAN timeout_reached = wait_on_ap_exec(context, timeout);
        if (timeout_reached) {
            // set LSB to indicate timeout was reached
            flags |= 0x1;
        }
    }

    status = send_result_message(context, flags, TRUE, ctx);
    if (EFI_ERROR(status)) {
        return status;
    }

    return EFI_SUCCESS;
}

EFI_STATUS handle_get_last_test_result(UINT8* payload, UINTN payload_length, ConnectionContext* ctx) {
    PrintDebug(L"Handling MSG_GETLASTTESTRESULT message.\n");
    EFI_STATUS status = EFI_SUCCESS;
    if (payload_length < 8) {
        FormatPrint(L"MSG_GETLASTTESTRESULT is too short, need at least 8 Bytes, got %u.\n", payload_length);
        send_status(0x1, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    UINT64 core_id = *(UINT64*)payload;

    if (core_id > MAX_CORE_COUNT) {
        FormatPrint(L"Core id %u is out of range, only %u max cores are supported.\n", core_id, MAX_CORE_COUNT);
        send_status(0x2, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    CoreContext* context = &core_contexts[core_id];

    status = send_core_status(context, FALSE, ctx);
    if (EFI_ERROR(status)) {
        return status;
    }

    // flags are defined as 0 for MSG_GETLASTTESTRESULT
    status = send_result_message(context, 0ull, TRUE, ctx);
    if (EFI_ERROR(status)) {
        return status;
    }

    return EFI_SUCCESS;
}

EFI_STATUS handle_send_machine_code(UINT8* payload, UINTN payload_length, ConnectionContext* ctx) {
    PrintDebug(L"Handling SENDMACHINECODE message.\n");
    if (payload_length < 8) {
        FormatPrint(L"SENDMACHINECODE is too short, need at least 8 Bytes, got %u.\n", payload_length);
        send_status(0x1, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    UINT32 target_slot = ((UINT32*)payload)[0];
    UINT32 machine_code_size = ((UINT32*)payload)[1];

    if (target_slot > MACHINE_CODE_SLOTS - 1) {
        FormatPrint(L"Invalid target slot, got %u, max %u.\n", target_slot, MACHINE_CODE_SLOTS - 1);
        send_status(0x2, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    if (machine_codes[target_slot].machine_code == NULL) {
        machine_codes[target_slot].machine_code = AllocateZeroPool(MACHINE_CODE_SIZE);
        if (machine_codes[target_slot].machine_code == NULL) {
            FormatPrint(L"Unable to allocate memory for machine_code.\n");
            send_status(0x3, FormatBuffer, ctx);
            return EFI_INVALID_PARAMETER;
        }
    }
    machine_codes[target_slot].length = machine_code_size;
    CopyMem(machine_codes[target_slot].machine_code, payload + 8, machine_code_size);

    send_status(0x0, NULL, ctx);

    return EFI_SUCCESS;
}

static void ensure_machine_code_slot_0() {
    // TODO: copy hardcoded machine code to slot 0
}

void init_ucode_execute() {
    ensure_machine_code_slot_0();
    init_cores();
}
