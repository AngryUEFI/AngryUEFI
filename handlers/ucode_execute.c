#include "ucode_execute.h"

#include <Base.h>
#include <Library/BaseLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/PrintLib.h>
#include <Protocol/SimpleTextOut.h>
#include <Uefi.h>
#include <Library/MemoryAllocationLib.h>

#include "Protocol.h"
#include "AngryUEFI.h"
#include "stubs.h"
#include "smp.h"
#include "ucode.h"

static MachineCodeMetaData machine_code_meta_data[MAX_CORE_COUNT] = {0};

// wrappers to change EFIAPI calling convention to native convention
static EFIAPI void apply_ucode_execute_machine_code_restore_efi_wrapper(void* buffer) {
    apply_ucode_execute_machine_code_restore(buffer);
    ((MachineCodeMetaData*)buffer)->execution_done = 1;
}

static EFIAPI void apply_ucode_execute_machine_code_simple_efi_wrapper(void* buffer) {
    apply_ucode_execute_machine_code_simple(buffer);
    ((MachineCodeMetaData*)buffer)->execution_done = 1;
}


EFI_STATUS handle_apply_ucode_execute_test(UINT8* payload, UINTN payload_length, ConnectionContext* ctx) {
    PrintDebug(L"Handling MSG_APPLYUCODEEXCUTETEST message.\n");
    EFI_STATUS status = EFI_SUCCESS;
    if (payload_length < 16) {
        FormatPrint(L"MSG_APPLYUCODEEXCUTETEST is too short, need at least 16 Bytes, got %u.\n", payload_length);
        send_status(0x1, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }
    UINT32* payload_u32 = (UINT32*)payload;

    UINT32 target_ucode_slot = payload_u32[0];
    UINT32 target_machine_code_slot = payload_u32[1];
    UINT32 target_core_id = payload_u32[2];
    UINT32 timeout = payload_u32[3];
    UINT32 options = payload_u32[4];
    if (ucodes[target_ucode_slot].ucode == NULL || ucodes[target_ucode_slot].length == 0) {
        FormatPrint(L"Target ucode slot %u is empty.\n", target_ucode_slot);
        send_status(0x2, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    if (machine_codes[target_machine_code_slot].machine_code == NULL || machine_codes[target_machine_code_slot].length == 0) {
        FormatPrint(L"Target machine code slot %u is empty.\n", target_machine_code_slot);
        send_status(0x3, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    if (target_core_id > get_available_cores() - 1 || target_core_id > MAX_CORE_COUNT - 1) {
        FormatPrint(L"Target core id %u is too high, got %u cores, max %u supported.\n", target_core_id, get_available_cores(), MAX_CORE_COUNT);
        send_status(0x4, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    if (timeout != 0) {
        FormatPrint(L"Due to no available TimerLib timeout is not supported.\n");
        send_status(0x5, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    MachineCodeMetaData* selected_meta_data = &machine_code_meta_data[target_core_id];
    selected_meta_data->current_machine_code_slot_address = machine_codes[target_machine_code_slot].machine_code;
    selected_meta_data->current_microcode_slot_address = ucodes[target_ucode_slot].ucode;
    selected_meta_data->ret_gpf_value = 0;
    selected_meta_data->ret_rdtsc_value = 0;
    selected_meta_data->execution_done = 0;
    ZeroMem(selected_meta_data->result_buffer, selected_meta_data->result_buffer_len);

    UINT8* ucode = ucodes[target_ucode_slot].ucode;
    UINT64 ucode_len = ucodes[target_ucode_slot].length;

    // generated by iterating the entire ucode
    // this should fill the cache with this update
    // the value is put into the meta data
    // so the compiler can not optimze them out
    UINT64 dummy = 0xdeadbeefdeadc0deull;
    for (UINT64 i = 0; i < ucode_len; i += 8) {
        for (UINT64 j = 0; j < 8; j++) {
            UINT8 b = ucode[i + j];
            dummy ^= ((UINT64)b) << j;
        }
    }
    selected_meta_data->ret_gpf_value = dummy;

    UINT64 flags = 0ull;
    if (target_core_id == 0) {
        if ((options & 0x01) == 0x01) {
            apply_ucode_execute_machine_code_restore(selected_meta_data);
        } else {
            apply_ucode_execute_machine_code_simple(selected_meta_data);
        }
    } else {
        EFI_EVENT event = NULL;
        if ((options & 0x01) == 0x01) {
            status = start_on_core(target_core_id, apply_ucode_execute_machine_code_restore_efi_wrapper, selected_meta_data, &event, timeout);
        } else {
            status = start_on_core(target_core_id, apply_ucode_execute_machine_code_simple_efi_wrapper, selected_meta_data, &event, timeout);
        }

        if (status != EFI_SUCCESS) {
            FormatPrint(L"Unable to start task on core %u: %r.\n", target_core_id, status);
            send_status(0x6, FormatBuffer, ctx);
            return status;
        }

        while (selected_meta_data->execution_done != 1) {
            // TODO: this is not actually waiting
            if (timeout != 0) {
                // set LSB to indicate timeout was reached
                flags |= 0x1;
                break;
            }
            CpuPause(); // spin loop
        }

        close_event(event);
    }

    UINT64* payload_u64 = (UINT64*)payload_buffer;
    payload_u64[0] = selected_meta_data->ret_rdtsc_value;
    payload_u64[1] = selected_meta_data->ret_gpf_value;
    payload_u64[2] = flags;
    payload_u64[3] = selected_meta_data->result_buffer_len;
    CopyMem(payload_buffer + 32, selected_meta_data->result_buffer, selected_meta_data->result_buffer_len);
    const UINTN response_size = 32 + 1024;

    EFI_STATUS Status = construct_message(response_buffer, sizeof(response_buffer), MSG_UCODEEXECUTETESTRESPONSE, payload_buffer, response_size, TRUE);
    if (EFI_ERROR(Status)) {
        FormatPrint(L"Unable to construct message: %r.\n", Status);
        return Status;
    }

    Status = send_message(response_buffer, response_size + HEADER_SIZE, ctx);
    if (EFI_ERROR(Status)) {
        FormatPrint(L"Unable to send message: %r.\n", Status);
        return Status;
    }

    return EFI_SUCCESS;
}


EFI_STATUS handle_send_machine_code(UINT8* payload, UINTN payload_length, ConnectionContext* ctx) {
    PrintDebug(L"Handling SENDMACHINECODE message.\n");
    if (payload_length < 8) {
        FormatPrint(L"SENDMACHINECODE is too short, need at least 8 Bytes, got %u.\n", payload_length);
        send_status(0x1, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    UINT32 target_slot = ((UINT32*)payload)[0];
    UINT32 machine_code_size = ((UINT32*)payload)[1];

    if (target_slot > MACHINE_CODE_SLOTS - 1) {
        FormatPrint(L"Invalid target slot, got %u, max %u.\n", target_slot, MACHINE_CODE_SLOTS - 1);
        send_status(0x2, FormatBuffer, ctx);
        return EFI_INVALID_PARAMETER;
    }

    if (machine_codes[target_slot].machine_code == NULL) {
        machine_codes[target_slot].machine_code = AllocateZeroPool(MACHINE_CODE_SIZE);
        if (machine_codes[target_slot].machine_code == NULL) {
            FormatPrint(L"Unable to allocate memory for machine_code.\n");
            send_status(0x3, FormatBuffer, ctx);
            return EFI_INVALID_PARAMETER;
        }
    }
    machine_codes[target_slot].length = machine_code_size;
    CopyMem(machine_codes[target_slot].machine_code, payload + 8, machine_code_size);
    
    send_status(0x0, NULL, ctx);

    return EFI_SUCCESS;
}

static void allocate_core_contexts() {
    for (UINTN i = 0; i < MAX_CORE_COUNT; i++) {
        MachineCodeMetaData* current = &machine_code_meta_data[i];
        current->result_buffer = AllocateZeroPool(RESULT_BUFFER_SIZE);
        current->result_buffer_len = RESULT_BUFFER_SIZE;
        current->scratch_space = AllocateZeroPool(MACHINE_CODE_SCRATCH_SPACE_SIZE);
        current->scratch_space_len = MACHINE_CODE_SCRATCH_SPACE_SIZE;
        current->core_id = i;
    }
}

static void ensure_machine_code_slot_0() {
    // TODO: copy hardcoded machine code to slot 0
}

void init_ucode_execute() {
    allocate_core_contexts();
    ensure_machine_code_slot_0();
}
